<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>METAR / TAF EMIRSUPPORT</title>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'JetBrains Mono', monospace;
      background: #2e3440;
      color: #d8dee9;
      margin: 0;
      padding: 0;
      line-height: 1.5;
      min-height: 100vh;
    }
    h1 {
      font-size: 16px;
      color: #eceff4;
      margin: 20px auto;
      text-align: center;
      font-family: 'JetBrains Mono', monospace;
    }
    #input-container {
      display: flex;
      gap: 10px;
      margin: 20px auto;
      max-width: 1400px;
      padding: 0 20px;
      justify-content: center;
      align-items: center;
      flex-wrap: wrap;
    }
    #utc-time {
      padding: 8px;
      font-size: 16px;
      color: #eceff4;
      background: #3b4252;
      border: 2px solid #4c566a;
      border-radius: 4px;
      font-family: 'JetBrains Mono', monospace;
      height: 20px;
      display: flex;
      align-items: center;
    }
    input[type="text"] {
      padding: 8px;
      font-size: 16px;
      border: 2px solid #4c566a;
      border-radius: 4px;
      background: #3b4252;
      color: #d8dee9;
      font-family: 'JetBrains Mono', monospace;
      width: 450px;
      height: 20px;
      text-transform: uppercase;
      outline: none;
      transition: border-color 0.3s ease, box-shadow 0.3s ease;
    }
    input[type="text"]:focus {
      border-color: #5e81ac;
      box-shadow: 0 0 8px rgba(94, 129, 172, 0.3);
    }
    button {
      padding: 8px 16px;
      font-size: 16px;
      border: none;
      border-radius: 4px;
      background: #5e81ac;
      color: #eceff4;
      cursor: pointer;
      font-family: 'JetBrains Mono', monospace;
      height: 36px;
      transition: background 0.3s ease;
    }
    button:hover {
      background: #81a1c1;
    }
    #error {
      color: #bf616a;
      text-align: center;
      margin: 10px 0;
      font-family: 'JetBrains Mono', monospace;
      font-size: 14px;
    }
    #loading {
      display: none;
      justify-content: center;
      align-items: center;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      color: #eceff4;
      font-size: 18px;
      z-index: 1000;
      font-family: 'JetBrains Mono', monospace;
    }
    #container {
      display: flex;
      flex-direction: row;
      justify-content: space-between;
      max-width: 1400px;
      margin: 0 auto;
      padding: 0 20px;
      gap: 20px;
    }
    #metar-taf-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 10px; /* This gap is between metar-entry-wrapper elements */
      padding-left: 0;
    }
    .metar-entry-wrapper {
        display: flex;
        align-items: flex-start; /* Aligns button to the top of the result-box */
        gap: 8px; /* Space between result-box and info-button */
        /* margin-bottom: 10px; /* Redundant if #metar-taf-container has gap */
    }
    #right-info-container {
      flex: 0 0 375px;
      display: flex;
      flex-direction: column;
      gap: 5px;
      margin-top: 10px;
      padding-right: 0;
    }
    .result-box {
      background: #3b4252;
      padding: 5px; /* Reduced padding */
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2); /* Adjusted shadow */
      border: 3px solid transparent; /* Reduced border */
      box-sizing: border-box;
      font-size: 14.5px;
      font-family: 'JetBrains Mono', monospace;
      line-height: 1.5;
      flex-grow: 1; /* Takes available space in metar-entry-wrapper */
    }
    .metar-content-area, .taf-content-area {
        /* padding-right: 80px; /* Removed */
        box-sizing: border-box;
        word-wrap: break-word;
    }
    .taf-content-area .taf-period {
        display: block;
    }
    .right-info-box {
      background: #45556b;
      padding: 4px; /* Reduced padding */
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2); /* Adjusted shadow */
      font-size: 14px;
      color: #ffffff;
      line-height: 1.2;
      border: 3px solid transparent; /* Reduced border */
      box-sizing: border-box;
      font-family: 'JetBrains Mono', monospace;
    }
    .right-info-box div {
      margin: 0;
      padding: 2px 4px;
      white-space: normal;
      font-size: 14px;
    }
    .metar-text {
      display: block;
      white-space: normal;
      overflow: visible;
    }
    .metar-text b {
      font-size: 16.5px;
    }
    .info-button {
      /* position: absolute; top: 8px; right: 8px; z-index: 10; */ /* Removed absolute positioning */
      padding: 4px 8px;
      font-size: 14px;
      background: #5e81ac;
      color: #eceff4;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-family: 'JetBrains Mono', monospace;
      transition: background 0.3s ease;
      height: 30px; /* Adjusted height to better match text */
      flex-shrink: 0; /* Prevent button from shrinking */
      margin-top: 3px; /* Align better with the top of the result-box title */
    }
    .info-button:hover {
      background: #81a1c1;
    }
    .wind-tabs {
      margin-top: 10px;
      font-family: 'JetBrains Mono', monospace;
    }
    .tab {
      display: inline-block;
      padding: 8px 16px;
      margin-right: 5px;
      background: #4c566a;
      border-radius: 4px;
      cursor: pointer;
      color: #eceff4;
      font-family: 'JetBrains Mono', monospace;
      transition: background 0.3s ease;
    }
    .tab.active {
      background: #5e81ac;
    }
    .tab:hover {
      background: #5e81ac;
    }
    .tab-content {
      display: none;
      margin-top: 10px;
      padding: 4px;
      background: #3b4252;
      color: #d8dee9;
      border-radius: 4px;
      font-size: 14px;
      font-family: 'JetBrains Mono', monospace;
      line-height: 1.5;
    }
    .tab-content.active {
      display: block;
    }
    .highlight-headwind {
      background: rgba(94, 129, 172, 0.2);
      padding: 2px 4px;
      border-radius: 4px;
      font-weight: bold;
      text-decoration: underline;
    }
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0, 0, 0, 0.5);
    }
    .modal-content {
      background: #3b4252;
      margin: 10% auto;
      padding: 20px;
      border-radius: 8px;
      width: 80%;
      max-width: 600px;
      position: relative;
      font-family: 'JetBrains Mono', monospace;
      color: #d8dee9;
    }
    #info-modal .modal-content {
      max-width: 500px;
      max-height: 150px;
    }
    #info-modal .modal-content table {
      width: 100%;
      border-collapse: separate;
      border-spacing: 0 8px;
    }
    #info-modal .modal-content td {
      padding: 8px;
      text-align: center;
    }
    #info-modal .modal-content button {
      width: 100%;
      padding: 8px;
      font-size: 14px;
      background: #5e81ac;
      color: #eceff4;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.3s ease;
    }
    #info-modal .modal-content button:hover {
      background: #81a1c1;
    }
    #info-modal .modal-content button:disabled {
      background: #4c566a;
      cursor: not-allowed;
    }
    #sector-modal .modal-content {
        max-width: 700px;
    }
    #sector-table {
        width: 100%;
        border-collapse: collapse;
        margin-bottom: 15px;
    }
    #sector-table td {
        padding: 8px;
        border: 1px solid #4c566a;
        text-align: left;
    }
    #sector-table label {
        display: block;
        cursor: pointer;
    }
    #sector-table input[type="checkbox"] {
        margin-right: 8px;
    }
    .modal-close {
      position: absolute;
      top: 10px;
      right: 15px;
      font-size: 24px;
      cursor: pointer;
      color: #eceff4;
    }
    .modal-close:hover,
    .modal-close:focus {
      color: #bf616a;
    }
    .progress-bar {
      width: 50%;
      height: 10px;
      background: #4c566a;
      border-radius: 5px;
      overflow: hidden;
      margin: 0 auto;
    }
    .progress-bar div {
      height: 100%;
      background: #5e81ac;
      transition: width 0.3s ease;
    }
    .cloud-bold-red { color: #ff4d73; font-weight: bold; text-decoration: underline; }
    .cloud-red { color: #ff4d73; font-weight: bold; text-decoration: underline; }
    .cloud-purple { color: #d966ff; font-weight: bold; text-decoration: underline; }
    .cloud-blue { color: #00b7eb; font-weight: bold; text-decoration: underline; }
    .cloud-normal { color: #d8dee9; font-weight: normal; }
    .visibility-red { color: #ff4d73; font-weight: bold; text-decoration: underline; }
    .visibility-purple { color: #d966ff; font-weight: bold; text-decoration: underline; }
    .visibility-orange { color: #ff9100; font-weight: bold; text-decoration: underline; }
    .visibility-normal { color: #d8dee9; font-weight: normal; }
    .weather-orange { color: #ff9100; font-weight: bold; text-decoration: underline; }
    .weather-red { color: #ff4d73; font-weight: bold; text-decoration: underline; }
    .cb-red { color: #ff4d73; font-weight: bold; text-decoration: underline; }
    .taf-marker {
      font-weight: bold;
      font-size: 16.5px;
    }
    .lvo-warning {
      color: #ffffff;
      font-weight: bold;
      background: #ff6666;
      padding: 2px 4px;
      border-radius: 2px;
      margin-right: 5px;
    }
    .cat3-warning {
      color: #ffffff;
      font-weight: bold;
      background: #ff6666;
      padding: 2px 4px;
      border-radius: 2px;
      margin-right: 5px;
    }
    .cat2-warning {
      color: #000000;
      font-weight: bold;
      background: #ffff00;
      padding: 2px 4px;
      border-radius: 2px;
      margin-right: 5px;
    }
    .cat1-warning {
      color: #000000;
      font-weight: bold;
      background: #ffffff;
      padding: 2px 4px;
      border-radius: 2px;
      margin-right: 5px;
    }
    .taf-period {
      margin-bottom: 2px;
      line-height: 1.5;
      padding: 1px 2px;
      border-radius: 4px;
    }
    .taf-period.period-1 { background: #3b4252; }
    .taf-period.period-2 { background: #3f4858; }
    .taf-period.period-3 { background: #454e5e; }
    .taf-period.period-4 { background: #4b5464; }
    .taf-period.period-5 { background: #515a6a; }
    .taf-period.period-6 { background: #576070; }
    .taf-period.period-7 { background: #5d6676; }
    .taf-period.period-8 { background: #636c7c; }
    .taf-period.period-9 { background: #697282; }
    .taf-period.period-10 { background: #6f7888; }
    .taf-period.period-11 { background: #757e8e; }
    .taf-period.period-12 { background: #7b8494; }
    .taf-period.period-13 { background: #818a9a; }
    .taf-period.period-14 { background: #8790a0; }
    .taf-period.period-15 { background: #8d96a6; }
    @keyframes fadeOut {
      from { opacity: 1; }
      to { opacity: 0; }
    }
    #error.fade-out {
      animation: fadeOut 1s ease forwards;
      animation-delay: 5s;
    }
    @media (max-width: 1280px) {
      #container {
        flex-direction: column;
        align-items: center;
      }
      #metar-taf-container {
        width: 100%;
        max-width: 600px;
        margin-left: 0;
        padding-left: 0;
      }
      #right-info-container {
        width: 100%;
        max-width: 600px;
        margin-right: 0;
        padding-right: 0;
        position: static;
      }
    }
    @media (max-width: 600px) {
      #input-container {
        flex-direction: column;
        align-items: center;
        padding: 0 10px;
      }
      #utc-time {
        font-size: 14px;
        height: 18px;
      }
      input[type="text"] {
        width: 100%;
        max-width: 100%;
        font-size: 14px;
        height: 18px;
      }
      button {
        font-size: 14px;
        height: 34px;
      }
      h1 {
        font-size: 14px;
        margin: 10px auto;
      }
      #error {
        font-size: 12px;
      }
      #loading {
        font-size: 16px;
      }
      .result-box {
        font-size: 13px;
        margin: 0;
        width: 100%;
        padding: 4px; /* Further reduce for small screens */
        border-width: 2px;
      }
      .metar-entry-wrapper {
        flex-direction: column; /* Stack box and button on small screens */
        align-items: stretch; /* Make button full width */
      }
      .info-button {
        margin-top: 5px; /* Space when stacked */
        width: 100%;
        height: 30px;
      }
      /* .metar-content-area, .taf-content-area {
        padding-right: 0px; /* No padding needed if button is stacked 
      } */
      .right-info-box {
        font-size: 12px;
        padding: 3px;
        border-width: 2px;
      }
      .modal-content {
        width: 90%;
        margin: 15% auto;
      }
      #sector-modal .modal-content {
        max-width: 90%;
      }
      #sector-table td {
        padding: 5px;
        font-size: 12px;
      }
      .wind-tabs {
        font-size: 13px;
      }
      .tab {
        padding: 6px 12px;
        font-size: 13px;
      }
      .tab-content {
        font-size: 13px;
      }
      /* .info-button {
        font-size: 12px;
        padding: 3px 6px;
      } */
      #info-modal .modal-content table {
        border-spacing: 0 6px;
      }
      #info-modal .modal-content button {
        font-size: 12px;
        padding: 6px;
      }
    }
  </style>
</head>
<body>
  <h1>METAR / TAF EMIRSUPPORT</h1>

  <div id="input-container">
    <button onclick="openSectorModal()" id="sector-button">Sektör</button>
    <span id="utc-time">00:00:00 UTC</span>
    <input type="text" id="airport-code" placeholder="ICAO veya IATA (virgülle ayrılarak)" />
    <button onclick="getWeather()">Sorgula</button>
  </div>

  <div id="error"></div>
  <div id="loading">Veriler yükleniyor...</div>
  <div id="container">
    <div id="metar-taf-container"></div>
    <div id="right-info-container"></div>
  </div>

  <div id="wind-modal" class="modal">
    <div class="modal-content">
      <span class="modal-close" onclick="closeAllModals()">×</span>
      <div id="modal-wind-content"></div>
    </div>
  </div>

  <div id="info-modal" class="modal">
    <div class="modal-content">
      <span class="modal-close" onclick="closeAllModals()">×</span>
      <div id="modal-info-content"></div>
    </div>
  </div>

  <div id="sector-modal" class="modal">
    <div class="modal-content">
      <span class="modal-close" onclick="closeAllModals()">×</span>
      <h2>Sektör Seçimi</h2>
      <div id="sector-selection-area">
        <table id="sector-table">
          </table>
      </div>
      <button onclick="querySectors()">Seçilen Sektörleri Sorgula</button>
    </div>
  </div>

  <script>
    const AVWX_API_TOKEN = "wVyA5NlNKZdiSdiJBAVTnOhTvcQWwB3UIe_g8i-xeCU";
    const CHECKWX_API_TOKEN = "f3c761d1fa234864a8bd1a919650d562";

    const runwaysData = {
      LKPR: [
        { le_ident: "04", he_ident: "22", length_ft: 12247, length_m: 3732, le_heading_degT: 40, he_heading_degT: 220 },
        { le_ident: "06", he_ident: "24", length_ft: 12189, length_m: 3715, le_heading_degT: 60, he_heading_degT: 240 },
        { le_ident: "12", he_ident: "30", length_ft: 10663, length_m: 3250, le_heading_degT: 120, he_heading_degT: 300 }
      ],
      LTFM: [
        { le_ident: "16L", he_ident: "34R", length_ft: 12303, length_m: 3750, le_heading_degT: 160, he_heading_degT: 340 },
        { le_ident: "16R", he_ident: "34L", length_ft: 12303, length_m: 3750, le_heading_degT: 160, he_heading_degT: 340 },
        { le_ident: "17L", he_ident: "35R", length_ft: 13451, length_m: 4100, le_heading_degT: 170, he_heading_degT: 350 },
        { le_ident: "17R", he_ident: "35L", length_ft: 13451, length_m: 4100, le_heading_degT: 170, he_heading_degT: 350 },
        { le_ident: "18", he_ident: "36", length_ft: 10039, length_m: 3060, le_heading_degT: 180, he_heading_degT: 360 }
      ]
      // Add more runway data as needed
    };

    const airportNames = {
      LTFM: "Istanbul Airport",
      LKPR: "Prague Airport"
      // Add more as needed
    };

    const allTurkishLTairports = ["LTFM", "LTAJ", "LTCG", "LTCC", "LTDB", "LTCA", "LTCE", "LTAU", "LTAZ", "LTAY", "LTAN", "LCEN", "LTCD", "LTFG", "LTCB", "LTAI", "LTDA", "LTAS", "LTAL", "LTCK", "LTAP", "LTCS", "LTCT", "LTAT", "LTCW", "LTCN", "LTFD", "LTAW", "LTCR", "LTAR", "LTCL", "LTCI", "LTCV", "LTCJ", "LTCP", "LTFO", "LTCU", "LTCF", "LTCO", "LTCM", "LTBZ", "LTFC", "LTAC", "LTFH", "LTBS", "LTBJ", "LTFE", "LTBA"];


    const iataToIcao = {
      IST: "LTFM",
      PRG: "LKPR"
      // Add more as needed
    };

    const fallbackCoordinates = {
      LTFM: { lat: 41.2753, lng: 28.7519 },
      LKPR: { lat: 50.1008, lng: 14.26 }
    };

    const sectorData = {
        "AFR1": "LTFM HEBA HEGN HESH HECA DGAA DBBB".split(" "),
        "AFR2": "HCMM LTFM HDAM HAAB HHAS HJJJ".split(" "),
        "AFR3": "HTDA LTFM HKJK HUEN HTZA HRYR FLKK HTKJ".split(" "),
        "BLKN": "LTFM LQSA LJLJ LWSK LYPG LBSF LDZA LYTV LYBE LWOH LDDU BKPR LBWN".split(" "),
        "DOM1": "LTFM LTAC LTFH LTAI LTBS LTBJ LTFE LTBA".split(" "),
        "DOM2": "LTFM LTAJ LTCG LTCC LTDB LTCA LTCE LTAU LTAZ LTAY LTAN LCEN LTCD LTFG LTCB LTAI LTDA LTAS LTAL".split(" "),
        "DOM3": "LTFM LTCK LTAP LTCS LTCT LTAT LTCW LTCN LTFD LTAW LTCR LTAR LTCL LTCI LTCV LTCJ LTCP LTFO LTCU LTCF LTCO LTCM LTBZ LTFC".split(" "),
        "EEU1": "LTAI LUKK UBBB LTFM UGTB UGSB LTFE".split(" "),
        "EEU2": "UAAA LTFM UTSS UTTT UCFM UATT LTAI UACC UTAA UAKK UATE UTSB UTNU UTDD UAIT".split(" "),
        "ENG": "LTFM EIDW EGPH EGCC EGBB EGKK EGLL EGSS".split(" "),
        "ER": "LTFM RJBB CYUL KJFK OPLA WMKK YSSY CYYZ VIDP ZMCK KDTW KORD VCBI OPIS OPKC FKKD VGHS VABB VHHH MPTO KSFO KDFW KATL KIAD DFFD VNKT GABS KMIA KIAH WSSS VVNB RJAA KBOS SAEZ SBGR KLAX KSEA ZGGG KEWR VVTS RKSI SKBO GOBD EBLG OMDW VMMC SCEL MMMX MMUN VOBL FAOR FQMA ZGSZ OTHH ZHCC DNMM GQNO KDEN RCTP CYVR UCFM ZSPD RJTT VTBS WADD UAAA FOOL RPLL VOMM FZAA MUHA SVMI WIII FACT FKYS LIMC FIMP ZBAA HKJK FCPP OAKB GFLL DRRN VTSP VRMM OJAI UGTB OLBA FNLU OKKK FTTJ FALE DNAA OERK VOHS SEQM GUCY YMML EHBK LTFJ FMMI".split(" "),
        "FRNS": "LTFM LFML LFMN LFPG LFLL LFSB LFBD LFBO GMMN DAAG".split(" "),
        "GERM1": "LTFM EDDF EDDL EDDM EDDS EDDN EDDP".split(" "),
        "GERM2": "LTFM EDDW EDDH EDDK EDDV EDDB".split(" "),
        "IBER": "LTFM LEMD LPPT LEMG LPPR LEVC LEBL LEBB".split(" "),
        "IRAK": "LTFM ORMM ORER ORBI".split(" "),
        "IRAN": "LTFM OITT OIIE OIFM OIMM OISS".split(" "),
        "ITLY": "LIMC LTFM LICJ LIRN LIPZ LIMF LIRF LIPE LICC LIBD LATI LIPX".split(" "),
        "MDTR": "DAAG LTFM LGAV LATI LGTS DTTA HLLM LMML HLLB DAOO DABC GMMN LTAC GMMX LIPE LIMC LIPX".split(" "),
        "MEA1": "OLBA LTFM OJAI OSDI OJAQ".split(" "),
        "MEA2": "LTFM OMDW OTHH OMDB OKKK OOMS OMAA OBBI LTCG".split(" "),
        "MEUR": "LTFM LROP LKPR LHBP LOWS LOWW LRCL LOWL LRCK".split(" "),
        "NEUR": "LTFM EFHK EKBI EVRA EKCH EYVI EPWA ENGM ESSA EETN ESGG LHBP EPKK EGSS".split(" "),
        "RUS1": "UUWW LTBS LTAI LTFE LTFM".split(" "),
        "RUS2": "ULLI LTFM UWKD LTAI".split(" "),
        "SUUD": "LTFM OEMA OERK OEJN LTAJ OSDI OEDF LTAI LTAC".split(" "),
        "WEUR": "LTFM LSGG EHAM ELLX EBBR LSZH GMMN EGSS EBLG EHBK".split(" ")
    };

    const cache = {
      get: (key) => {
        const item = localStorage.getItem(key);
        if (!item) return null;
        const { data, timestamp } = JSON.parse(item);
        if (Date.now() - timestamp > 10 * 60 * 1000) {
          localStorage.removeItem(key);
          return null;
        }
        return data;
      },
      set: (key, data) => {
        localStorage.setItem(key, JSON.stringify({ data, timestamp: Date.now() }));
      }
    };

    async function fetchAirportCoordinates(icao) {
      const cacheKey = 'airport_coordinates';
      const cachedData = cache.get(cacheKey);
      if (cachedData && cachedData[icao]) {
            return cachedData;
      }
      
      console.log('[DEBUG] Fetching or refreshing airport coordinates CSV...');
      for (let attempt = 1; attempt <= 3; attempt++) {
        try {
          const response = await fetch('https://raw.githubusercontent.com/ip2location/ip2location-iata-icao/master/iata-icao.csv', {
            cache: 'no-store',
            signal: AbortSignal.timeout(5000)
          });
          if (!response.ok) throw new Error(`CSV alınamadı (Durum: ${response.status})`);
          const csvText = await response.text();
          
          const lines = csvText.split('\n').filter(line => line.trim() !== '');
          let headers = lines[0].split('","').map(h => h.replace(/^"|"$/g, ''));
          let icaoIndex = headers.indexOf('icao');
          let latIndex = headers.indexOf('latitude');
          let lngIndex = headers.indexOf('longitude');

          if (icaoIndex === -1 || latIndex === -1 || lngIndex === -1) {
            console.warn('[DEBUG] Standard CSV headers not found, trying alternatives...');
            // Attempt to find headers even if they are slightly different, e.g. different case
            headers = lines[0].toLowerCase().split('","').map(h => h.replace(/^"|"$/g, ''));
            icaoIndex = headers.indexOf('icao');
            latIndex = headers.indexOf('latitude');
            if (latIndex === -1) latIndex = headers.indexOf('latitude部分:latitude'); // Specific alternative from original code
            lngIndex = headers.indexOf('longitude');

            if (icaoIndex === -1 || latIndex === -1 || lngIndex === -1) {
                 throw new Error('CSV başlıklarında icao, latitude veya longitude eksik');
            }
          }

          const coordinates = {};
          for (let i = 1; i < lines.length; i++) {
            const values = lines[i].split('","').map(v => v.replace(/^"|"$/g, ''));
            if (values.length < headers.length) continue;

            const lineIcao = values[icaoIndex];
            const lat = parseFloat(values[latIndex]);
            const lng = parseFloat(values[lngIndex]);

            if (lineIcao && !isNaN(lat) && !isNaN(lng)) {
              coordinates[lineIcao.toUpperCase()] = { lat, lng }; // Store ICAO in uppercase
            }
          }
          cache.set(cacheKey, coordinates);
          return coordinates;
        } catch (e) {
          console.error('[DEBUG] Coordinate fetch attempt', attempt, 'failed:', e.message);
          if (attempt === 3) {
            showError(`Koordinat CSV'si alınamadı: ${e.message}. Fallback veriler kullanılıyor.`);
            return fallbackCoordinates;
          }
          await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
        }
      }
      showError('Koordinat CSV’si alınamadı. Fallback veriler kullanılıyor.');
      return fallbackCoordinates;
    }

    function calculateSunriseSunset(latitude, longitude, icao) {
        if (latitude === undefined || longitude === undefined || isNaN(latitude) || isNaN(longitude)) {
            console.warn(`[DEBUG] Invalid or missing coordinates for ${icao}: Lat=${latitude}, Lng=${longitude}`);
            return { sunrise: "Koordinat yok", sunset: "Koordinat yok" };
        }
      try {
        const date = new Date();
        function degToRad(deg) { return (deg * Math.PI) / 180; }
        function radToDeg(rad) { return (rad * 180) / Math.PI; }
        const start = new Date(date.getFullYear(), 0, 0);
        const diff = date - start;
        const oneDay = 1000 * 60 * 60 * 24;
        const N = Math.floor(diff / oneDay);
        const lngHour = longitude / 15;
        const tRise = N + ((6 - lngHour) / 24);
        const tSet = N + ((18 - lngHour) / 24);
        function sunMeanAnomaly(t) { return (0.9856 * t) - 3.289; }
        function sunTrueLongitude(M) {
          let L = M + (1.916 * Math.sin(degToRad(M))) + (0.020 * Math.sin(degToRad(2 * M))) + 282.634;
          if (L > 360) L -= 360; if (L < 0) L += 360; return L;
        }
        function sunRightAscension(L) {
          let RA = radToDeg(Math.atan(0.91764 * Math.tan(degToRad(L))));
          if (RA < 0) RA += 360;
          const Lquadrant = Math.floor(L / 90) * 90;
          const RAquadrant = Math.floor(RA / 90) * 90;
          RA = RA + (Lquadrant - RAquadrant); return RA / 15;
        }
        function sunDeclination(L) {
          const sinDec = 0.39782 * Math.sin(degToRad(L));
          const cosDec = Math.cos(Math.asin(sinDec)); return { sinDec, cosDec };
        }
        function sunLocalHourAngle(sinDec, cosDec, zenith, lat, isSunrise) {
          const cosH = (Math.cos(degToRad(zenith)) - (sinDec * Math.sin(degToRad(lat)))) / (cosDec * Math.cos(degToRad(lat)));
          if (cosH > 1 || cosH < -1) return null;
          return isSunrise ? (360 - radToDeg(Math.acos(cosH))) / 15 : radToDeg(Math.acos(cosH)) / 15;
        }
        function calculateTime(tFactor, isSunrise) {
          const M = sunMeanAnomaly(tFactor); const L = sunTrueLongitude(M);
          const RA = sunRightAscension(L); const { sinDec, cosDec } = sunDeclination(L);
          const zenith = 90.833;
          const H = sunLocalHourAngle(sinDec, cosDec, zenith, latitude, isSunrise);
          if (H === null) return `Sürekli ${isSunrise ? 'aydınlık' : 'karanlık'}`;
          const T = H + RA - (0.06571 * tFactor) - 6.622;
          let UT = T - lngHour;
          if (UT < 0) UT += 24; if (UT >= 24) UT -= 24;
          const hour = Math.floor(UT); const minute = Math.floor((UT - hour) * 60);
          return `${hour.toString().padStart(2,'0')}:${minute.toString().padStart(2,'0')}`;
        }
        const sunrise = calculateTime(tRise, true);
        const sunset = calculateTime(tSet, false);
        return { sunrise, sunset };
      } catch (e) {
        console.error(`[DEBUG] Sunrise/Sunset Calculation error for ${icao}:`, e.message);
        return { sunrise: "Hesaplama hatası", sunset: "Hesaplama hatası" };
      }
    }

    function updateUTCTime() {
      const now = new Date();
      const utcTimeString = now.toLocaleTimeString('tr-TR', { hour: '2-digit', minute: '2-digit', second: '2-digit', timeZone: 'UTC' });
      document.getElementById('utc-time').textContent = `${utcTimeString} UTC`;
    }
    setInterval(updateUTCTime, 1000);
    updateUTCTime();

    function showError(msg) {
      const errorDiv = document.getElementById("error");
      errorDiv.textContent = msg;
      errorDiv.classList.remove('fade-out');
      void errorDiv.offsetWidth;
      if (msg.includes("Tüm havalimanları başarıyla alındı") || msg.startsWith("Veri alınamayan havalimanları") && !msg.includes("Hiçbir havalimanı")) {
        errorDiv.classList.add('fade-out');
        setTimeout(() => {
          errorDiv.textContent = '';
          errorDiv.classList.remove('fade-out');
        }, 6000);
      }
    }

    function clearError() {
      showError("");
    }

    function colorizeAndScore(text) {
        if (!text) return { coloredText: 'Veri yok', score: 0, highestColor: '#d8dee9', needsLVOWarning: false, catWarning: '' };
        let redCount = 0, purpleCount = 0, orangeCount = 0, blueCount = 0;
        let result = text;
        let highestColor = '#00ff41'; 
        let needsLVOWarning = false;
        let catWarning = '';

        const visibilityMatch = text.match(/\b(\d{4})\b(?!\d*KT)(?!\d*Z)(?!\s*MPS)(?!\s*SM)/);
        const visibility = visibilityMatch ? parseInt(visibilityMatch[1], 10) : null;

        let rvrValue = null;
        const rvrRe = /\bR\d{2}[LRC]?\/([PM]?\d{4})(V[PM]?\d{4})?(FT)?\b/g;
        let rvrMatch;
        while((rvrMatch = rvrRe.exec(text)) !== null) {
            const val1 = parseInt(rvrMatch[1].replace(/[PM]/, ''), 10);
            if (rvrValue === null || val1 < rvrValue) rvrValue = val1;
            if (rvrMatch[2]) {
                const val2 = parseInt(rvrMatch[2].replace(/[VPM]/, ''), 10);
                if (val2 < rvrValue) rvrValue = val2;
            }
        }
        
        let bkn001 = /\bBKN001\b/.test(text);
        let ovc001 = /\bOVC001\b/.test(text);
        let bkn002 = /\bBKN002\b/.test(text);
        let ovc002 = /\bOVC002\b/.test(text);

        if ((visibility !== null && visibility <= 550) || bkn001 || ovc001 || bkn002 || ovc002) {
            needsLVOWarning = true;
        }

        if (bkn001 || ovc001 || (visibility !== null && visibility <= 300) || (rvrValue !== null && rvrValue <= 300)) {
            catWarning = 'CAT3';
            highestColor = '#ff6666'; 
        } else if ((visibility !== null && visibility >= 301 && visibility <= 799) || (rvrValue !== null && rvrValue >= 301 && rvrValue <= 799)) {
            catWarning = 'CAT2';
            highestColor = '#ffff00'; 
        } else if ((visibility !== null && visibility >= 800 && visibility <= 1500) || bkn002 || ovc002 || (rvrValue !== null && rvrValue >= 800 && rvrValue <= 1500)) {
            catWarning = 'CAT1';
            highestColor = '#A9A9A9';
        }

        result = result.replace(/\b(PROB30 TEMPO|PROB40 TEMPO|BECMG|TEMPO|PROB30|PROB40|FM\d{6})\b/g, `<span class="taf-marker">$1</span>`);
        result = result.replace(/\b(CB|TCU)\b/g, `<span class="cb-red">$1</span>`);

        result = result.replace(/\b(FEW|SCT|BKN|OVC)(\d{3})(CB|TCU)?\b/g, (match, layer, height, cbOrTcu) => {
            const h = parseInt(height, 10);
            let cloudColorClass = 'cloud-normal';
            if (layer === "BKN" || layer === "OVC") {
                if (h <= 1) cloudColorClass = 'cloud-bold-red';
                else if (h <= 3) cloudColorClass = 'cloud-red';
                else if (h <= 7) cloudColorClass = 'cloud-purple';
                else if (h <= 149) cloudColorClass = 'cloud-blue';
            }
            return `<span class="${cloudColorClass}">${layer}${height}</span>${cbOrTcu ? `<span class="cb-red">${cbOrTcu}</span>` : ""}`;
        });

        result = result.replace(/\b(\d{4})\b(?!\d*KT)(?!\d*Z)(?!\s*MPS)(?!\s*SM)/g, (match) => {
            const v = parseInt(match, 10);
            if (v >= 0 && v <= 300) return `<span class="visibility-red">${match}</span>`;
            if (v >= 301 && v <= 750) return `<span class="visibility-purple">${match}</span>`;
            if (v >= 751 && v <= 1499) return `<span class="visibility-orange">${match}</span>`;
            return `<span class="visibility-normal">${match}</span>`;
        });
        
        const weatherPhenomena = /(\s|^)([+-])?(MI|PR|BC|DR|BL|SH|TS|FZ)?(DZ|RA|SN|SG|IC|PL|GR|GS|UP|BR|FG|FU|VA|DU|SA|HZ|PY|PO|SQ|FC|SS|DS)(\s|$)/g;
        result = result.replace(weatherPhenomena, (match, p1, p2, p3, p4, p5, p6) => {
            let intensity = p2 || '';
            let descriptor = p3 || '';
            let phenomenon = p4;
            let fullCode = intensity + descriptor + phenomenon;
            let weatherClass = '';
            if (['+RA', '+SHRA', '+TSRA', '+SN', 'SN', 'DS', 'SS', 'TSGR', 'TSGS', 'GR', 'GS', 'FC', '+FC', 'FZFG', 'FZRA', 'TS'].some(c => fullCode.includes(c)) || intensity === '+' || phenomenon === 'TS' || phenomenon === 'SQ' || phenomenon === 'FC' || phenomenon === 'SS' || phenomenon === 'DS' ) {
                weatherClass = 'weather-red';
            } else if (['-RA', '-SHRA', '-TSRA', '-SN', 'SHRA', 'SHSN', 'RA', 'DZ', 'FG', 'BR'].some(c => fullCode.includes(c)) || intensity === '-' || descriptor === 'SH') {
                weatherClass = 'weather-orange';
            }
            return `${p1}<span class="${weatherClass}">${fullCode}</span>${p6}`;
        });

        const score = redCount * 5 + purpleCount * 4 + orangeCount * 3 + blueCount * 1; // Score is illustrative
        return { coloredText: result, score, highestColor: catWarning ? highestColor : (needsLVOWarning ? '#ff6666' : '#00ff41'), needsLVOWarning, catWarning };
    }

    function parseTAFPeriods(tafRaw) {
      if (!tafRaw) return { periods: [{ text: 'Veri bulunamadı', score: 0, needsLVOWarning: false, catWarning: '' }], totalScore: 0 };

      // Improved TAF parsing to handle various groups like FM, TEMPO, BECMG, PROB
      // This regex aims to split the TAF string by period change indicators
      // It looks for FM, BECMG, TEMPO, or PROB followed by a time or just the keyword
      // and includes the keyword in the split part.
      const periodKeywords = /\s+(?=FM\d{6}|BECMG|TEMPO|PROB\d{2}(\sTEMPO)?)/g;
      let periodsRaw = tafRaw.split(periodKeywords);

      // The first part of TAF before any FM/BECMG/TEMPO is the initial forecast period.
      // Often it includes the validity time like 030000Z 031200Z or 1218/1318
      // We need to ensure that the initial part is correctly identified.
      
      let baseForecast = "";
      let subsequentPeriods = [];

      // A common pattern is TAF LFTM 121700Z 1218/1324 ...
      // The first period might not start with FM.
      // For simplicity, if no periodKeywords are found, the whole TAF is one period.
      if (periodsRaw.length === 1 && !tafRaw.match(/^(FM\d{6}|BECMG|TEMPO|PROB\d{2})/)) {
          baseForecast = tafRaw;
      } else {
          baseForecast = periodsRaw[0]; // The initial part
          subsequentPeriods = periodsRaw.slice(1);
      }

      const parsedPeriods = [];
      let totalPeriodScore = 0;

      if (baseForecast && baseForecast.trim() !== "") {
          const analysis = colorizeAndScore(baseForecast.trim());
          parsedPeriods.push({ 
              text: analysis.coloredText, 
              score: analysis.score, 
              needsLVOWarning: analysis.needsLVOWarning, 
              catWarning: analysis.catWarning 
          });
          totalPeriodScore += analysis.score;
      }

      subsequentPeriods.forEach(periodStr => {
          if (periodStr && periodStr.trim() !== "") {
              const analysis = colorizeAndScore(periodStr.trim());
              parsedPeriods.push({ 
                  text: analysis.coloredText, 
                  score: analysis.score, 
                  needsLVOWarning: analysis.needsLVOWarning, 
                  catWarning: analysis.catWarning 
              });
              totalPeriodScore += analysis.score;
          }
      });
      
      return parsedPeriods.length > 0
        ? { periods: parsedPeriods, totalScore: totalPeriodScore }
        : { periods: [{ text: 'TAF ayrıştırılamadı', score: 0, needsLVOWarning: false, catWarning: '' }], totalScore: 0 };
    }


    function calculateWindComponents(windDirection, windSpeed, runways, isTrueNorth, magneticVariation = 0) {
      const toRad = Math.PI / 180; const results = [];
      runways.forEach(runway => {
        const headings = [ { ident: runway.le_ident, heading: runway.le_heading_degT }, { ident: runway.he_ident, heading: runway.he_heading_degT } ].filter(h => h.heading !== undefined && h.ident);
        headings.forEach(({ ident, heading }) => {
          let effectiveHeading = isTrueNorth ? heading : (heading - magneticVariation + 360) % 360;
          let angle = Math.abs(windDirection - effectiveHeading); if (angle > 180) angle = 360 - angle;
          const angleRad = angle * toRad;
          const headwind = windSpeed * Math.cos(angleRad); const crosswind = windSpeed * Math.sin(angleRad);
          const tailwind = -headwind; let componentText = '';
          if (headwind > 0.1) componentText = `Headwind: ${headwind.toFixed(1)} kts`;
          else if (tailwind > 0.1) componentText = `Tailwind: ${tailwind.toFixed(1)} kts`;
          else componentText = 'No sig. head/tailwind';
          if (Math.abs(crosswind) > 0.1) componentText += `, Xwind: ${Math.abs(crosswind).toFixed(1)} kts`;

          results.push({ ident, length_ft: runway.length_ft, length_m: runway.length_m, componentText, headwind: headwind > 0.1 ? headwind : 0 });
        });
      });
      return results;
    }

    async function fetchWeatherForAirport(icao, retryCount = 2, useCheckWX = true) {
      const cacheKey = `${icao}_${useCheckWX ? 'checkwx' : 'avwx'}`;
      const cachedData = cache.get(cacheKey);
      if (cachedData) return cachedData;

      const headers = useCheckWX
        ? { "X-API-Key": CHECKWX_API_TOKEN }
        : { Authorization: `Bearer ${AVWX_API_TOKEN}` };
      const baseUrl = useCheckWX
        ? "https://api.checkwx.com"
        : "https://avwx.rest/api";

      for (let attempt = 1; attempt <= retryCount; attempt++) {
        try {
          const metarResp = await fetch( `${baseUrl}/metar/${icao}?format=json&decoded=true`, { headers });
          if (!metarResp.ok) throw new Error(`METAR alınamadı (${metarResp.status})`);
          const metarJson = await metarResp.json();
          const metarRaw = useCheckWX 
            ? (metarJson.data && metarJson.data.length > 0 ? metarJson.data[0].raw || metarJson.data[0] : null) // Prefer raw if available
            : metarJson.raw;
          if (!metarRaw) throw new Error("METAR raporu boş veya format hatalı");

          let tafRaw = null;
          try {
            const tafResp = await fetch( `${baseUrl}/taf/${icao}?format=json&decoded=true`, { headers });
            if (tafResp.ok) {
              const tafJson = await tafResp.json();
              tafRaw = useCheckWX 
                  ? (tafJson.data && tafJson.data.length > 0 ? tafJson.data[0].raw || tafJson.data[0] : null) // Prefer raw
                  : tafJson.raw;
            } else {
              console.warn(`TAF alınamadı (${tafResp.status}) for ${icao}.`);
            }
          } catch (tafError) {
             console.warn(`TAF fetch error for ${icao}: ${tafError.message}`);
          }

          const metarColored = colorizeAndScore(metarRaw);
          const tafParsed = parseTAFPeriods(tafRaw); 

          const windMatch = metarRaw.match(/(VRB|\d{3})(\d{2,3})(G(\d{2,3}))?KT/);
          const windDirection = windMatch && windMatch[1] !== 'VRB' ? parseInt(windMatch[1], 10) : null;
          const windSpeed = windMatch ? (windMatch[4] ? parseInt(windMatch[4], 10) : parseInt(windMatch[2], 10)) : null;

          const result = {
            icao,
            metar: metarColored,
            taf: tafParsed,
            score: metarColored.score + (tafParsed.totalScore || 0),
            windDirection,
            windSpeed,
            metarRaw: metarRaw, // Store raw for debugging or other uses
            tafRaw: tafRaw 
          };

          cache.set(cacheKey, result);
          return result;
        } catch (e) {
          if (icao.toUpperCase() === "LTDB" && attempt === retryCount && useCheckWX) {
            try {
              const data = await fetchWeatherForAirport("LTDX", 1, true);
              cache.set(cacheKey, data);
              return { ...data, icao: "LTDB (LTDX)" };
            } catch (ltdxError) { console.error(`LTDB ve LTDX için veri alınamadı: ${ltdxError.message}`);}
          }
          if (attempt === retryCount) {
            console.error(`${icao} için veri alınamadı (${useCheckWX ? 'CheckWX' : 'AVWX'}): ${e.message}`);
            throw e; 
          }
          await new Promise(resolve => setTimeout(resolve, 300 * attempt));
        }
      }
    }

    function chunkArray(array, size) {
      const chunks = [];
      for (let i = 0; i < array.length; i += size) {
        chunks.push(array.slice(i, i + size));
      }
      return chunks;
    }

    function renderWindComponents(result, isTrueNorth) {
      const baseIcao = result.icao.split(" ")[0];
      const runways = runwaysData[baseIcao] || [];
      if (!result.windDirection || !result.windSpeed || runways.length === 0) {
        return runways.length === 0 ? 'Pist verisi bulunamadı.' : 'Rüzgar bilgisi METAR\'da yok.';
      }
      // ... (rest of the function unchanged, ensure it uses result.windDirection etc.)
      const components = calculateWindComponents( result.windDirection, result.windSpeed, runways, isTrueNorth, 0 );
      const maxHeadwind = Math.max(0, ...components.map(c => c.headwind));
      const bestRunways = components.filter(c => c.headwind === maxHeadwind && c.headwind > 0.1);
      let html = `<strong>${isTrueNorth ? 'True North' : 'Magnetic North'}</strong><br />`;
      components.sort((a,b) => b.headwind - a.headwind).forEach((comp) => {
        const isBest = bestRunways.some(br => br.ident === comp.ident);
        const highlightClass = isBest ? 'highlight-headwind' : '';
        html += `<div class="${highlightClass}">${comp.ident} - ${comp.length_ft} ft (${comp.length_m} m) - ${comp.componentText}</div>`;
      });
      return html || 'Pist verisi veya rüzgar bilgisi yetersiz.';
    }

    function renderRightInfo(results, rightContainer) {
      const rightFragment = document.createDocumentFragment();
      const seenIcaosRight = new Set(); 

      results.forEach(r => {
        if (seenIcaosRight.has(r.icao)) return;
        seenIcaosRight.add(r.icao);

        const rightBox = document.createElement('div');
        rightBox.className = 'right-info-box';
        rightBox.style.borderColor = r.metar.highestColor;
        const baseIcao = r.icao.split(" ")[0];
        rightBox.innerHTML = `
          <div><strong style="font-size:16px;">${r.icao} - ${airportNames[baseIcao] || baseIcao}</strong></div>
          <div class="metar-text"><b style="font-size:16.5px;">METAR:</b> ${r.metar.coloredText || 'Veri bulunamadı'}</div>
        `;
        rightFragment.appendChild(rightBox);
      });

      rightContainer.innerHTML = '';
      rightContainer.appendChild(rightFragment);
    }

    function renderVisibleResults(results, metarContainer, rightContainer) {
      const metarFragment = document.createDocumentFragment();
      const seenIcaosMain = new Set(); 

      results.sort((a, b) => (b.metar.score + (b.taf.totalScore || 0)) - (a.metar.score + (a.taf.totalScore || 0)));

      results.forEach(r => {
        if (seenIcaosMain.has(r.icao)) return; 
        seenIcaosMain.add(r.icao);

        const entryWrapper = document.createElement('div');
        entryWrapper.className = 'metar-entry-wrapper';
        
        const resultBox = document.createElement('div');
        resultBox.className = 'result-box';
        resultBox.style.borderColor = r.metar.highestColor; 
        resultBox.setAttribute('data-icao', r.icao); // For linking

        const metarWarnings = [];
        if (r.metar.catWarning) metarWarnings.push(`<span class="${r.metar.catWarning.toLowerCase()}-warning">${r.metar.catWarning}</span>`);
        if (r.metar.needsLVOWarning) metarWarnings.push('<span class="lvo-warning">LVO</span>');
        const metarWarningText = metarWarnings.join(' ');

        const tafPeriodsHtml = r.taf.periods && r.taf.periods.length > 0 && r.taf.periods[0].text !== 'Veri bulunamadı' && r.taf.periods[0].text !== 'TAF ayrıştırılamadı'
          ? r.taf.periods.map((p, index) => {
                const periodWarningsList = [];
                if (p.catWarning) periodWarningsList.push(`<span class="${p.catWarning.toLowerCase()}-warning">${p.catWarning}</span>`);
                if (p.needsLVOWarning) periodWarningsList.push('<span class="lvo-warning">LVO</span>');
                const periodWarningText = periodWarningsList.join(' ');
                return `<span class="taf-period period-${index + 1}">${periodWarningText ? periodWarningText + ' ' : ''}${p.text}</span>`;
              }).join('')
          : `<span class="taf-period period-1">${r.tafRaw ? 'TAF ayrıştırılamadı' : 'TAF verisi yok'}</span>`;

        const baseIcao = r.icao.split(" ")[0];
        const tabsId = `wind-tabs-${baseIcao.replace(/[^a-zA-Z0-9]/g, '')}`;
        const sunriseSunsetId = `sunrise-sunset-${baseIcao.replace(/[^a-zA-Z0-9]/g, '')}`;
        const infoId = `info-${baseIcao.replace(/[^a-zA-Z0-9]/g, '')}`;
        
        let windTabsRenderContent = '';
        const currentRunways = runwaysData[baseIcao];
        if (currentRunways) {
          if (r.windDirection !== null && r.windSpeed !== null) {
            windTabsRenderContent = `
              <div id="${tabsId}" class="wind-tabs">
                <div class="tab active" data-tab-id="${tabsId}-magnetic">Magnetic North</div>
                <div class="tab" data-tab-id="${tabsId}-true">True North</div>
                <div id="${tabsId}-magnetic" class="tab-content active">${renderWindComponents(r, false)}</div>
                <div id="${tabsId}-true" class="tab-content">${renderWindComponents(r, true)}</div>
              </div>`;
          } else { windTabsRenderContent = `<div id="${tabsId}" class="wind-tabs"><div>Rüzgar bilgisi METAR'da mevcut değil.</div></div>`; }
        } else { windTabsRenderContent = `<div id="${tabsId}" class="wind-tabs"><div>Bu havalimanı için pist verisi bulunamadı.</div></div>`; }
        
        resultBox.setAttribute('data-wind-tabs-html', windTabsRenderContent);


        resultBox.innerHTML = `
          <div><strong style="font-size:16px;">${r.icao} - ${airportNames[baseIcao] || baseIcao}</strong></div>
          <b style="font-size:16.5px;">METAR:</b>
          <div class="metar-content-area">
            ${metarWarningText ? metarWarningText + '<br />' : ''}${r.metar.coloredText || 'Veri bulunamadı'}
          </div>
          <b style="font-size:16.5px;">TAF:</b>
          <div class="taf-content-area">${tafPeriodsHtml}</div>`;
        
        const infoButton = document.createElement('button');
        infoButton.className = 'info-button';
        infoButton.textContent = 'Bilgi';
        infoButton.setAttribute('data-info-id', infoId);
        infoButton.setAttribute('data-icao', r.icao); // Full ICAO for exact match
        infoButton.setAttribute('data-base-icao', baseIcao); // Base ICAO for data lookups
        infoButton.setAttribute('data-tabs-id', tabsId);
        // infoButton.setAttribute('data-sunrise-sunset-id', sunriseSunsetId); // Not directly used by button, but good to have
        infoButton.setAttribute('data-wind-direction', r.windDirection || '');
        infoButton.setAttribute('data-wind-speed', r.windSpeed || '');

        entryWrapper.appendChild(resultBox);
        entryWrapper.appendChild(infoButton);
        metarFragment.appendChild(entryWrapper);
      });

      metarContainer.innerHTML = '';
      metarContainer.appendChild(metarFragment);
      renderRightInfo(results, rightContainer);

      document.querySelectorAll('.info-button').forEach(button => {
        button.addEventListener('click', () => {
          const icao = button.getAttribute('data-icao'); // Full ICAO for display
          const baseIcaoForData = button.getAttribute('data-base-icao'); // Base ICAO for data keys
          // const tabsIdFromButton = button.getAttribute('data-tabs-id');
          const windDirection = button.getAttribute('data-wind-direction');
          const windSpeed = button.getAttribute('data-wind-speed');
          const windDisabled = !runwaysData[baseIcaoForData] || windDirection === '' || windSpeed === '';
          
          const infoModalContent = document.getElementById('modal-info-content');
          infoModalContent.innerHTML = `
            <table>
              <tr><td><button class="wind-component-button" data-icao="${icao}" ${windDisabled ? 'disabled' : ''}>Wind Component</button></td></tr>
              <tr><td><button class="sunrise-sunset-button" data-icao="${icao}">S/S</button></td></tr>
            </table>`;
          document.getElementById('info-modal').style.display = 'block';
          document.getElementById('wind-modal').style.display = 'none';

          const windCompButton = infoModalContent.querySelector('.wind-component-button');
          if (windCompButton && !windCompButton.disabled) {
            windCompButton.addEventListener('click', () => {
              const resultBoxForWind = document.querySelector(`.result-box[data-icao="${icao}"]`);
              const storedWindTabsHtml = resultBoxForWind.getAttribute('data-wind-tabs-html');
              const windModalContentEl = document.getElementById('modal-wind-content');
              windModalContentEl.innerHTML = storedWindTabsHtml;
              document.getElementById('wind-modal').style.display = 'block';
              document.getElementById('info-modal').style.display = 'none';

              const currentTabsContainer = windModalContentEl.querySelector('.wind-tabs');
              if (currentTabsContainer) {
                const currentTabsId = currentTabsContainer.id;
                document.querySelectorAll(`#${currentTabsId} .tab`).forEach(tab => {
                  tab.addEventListener('click', () => {
                    const tabId = tab.getAttribute('data-tab-id');
                    const type = tabId.includes('magnetic') ? 'magnetic' : 'true';
                    showTab(currentTabsId, type);
                  });
                });
                const activeTabElement = document.querySelector(`#${currentTabsId} .tab.active`);
                if (activeTabElement) {
                   const initialType = activeTabElement.getAttribute('data-tab-id').includes('magnetic') ? 'magnetic' : 'true';
                   showTab(currentTabsId, initialType);
                } else if (document.querySelector(`#${currentTabsId} .tab`)) {
                   const firstTabType = document.querySelector(`#${currentTabsId} .tab`).getAttribute('data-tab-id').includes('magnetic') ? 'magnetic' : 'true';
                   showTab(currentTabsId, firstTabType);
                }
              }
            });
          }

          const ssButton = infoModalContent.querySelector('.sunrise-sunset-button');
          ssButton.addEventListener('click', async () => {
            const loadingDiv = document.getElementById('loading');
            loadingDiv.style.display = 'flex';
            loadingDiv.textContent = `${icao} için Sunrise/Sunset verileri hesaplanıyor...`;
            
            const allCoordinates = await fetchAirportCoordinates(baseIcaoForData.toUpperCase()); // Fetch with uppercase
            const coords = allCoordinates[baseIcaoForData.toUpperCase()] || fallbackCoordinates[baseIcaoForData.toUpperCase()];

            let data;
            if (coords) data = calculateSunriseSunset(coords.lat, coords.lng, icao);
            else data = { sunrise: "Koordinatlar bilinmiyor", sunset: "Koordinatlar bilinmiyor" };
            
            await new Promise(resolve => setTimeout(resolve, 500));
            const windModalContentEl = document.getElementById('modal-wind-content');
            windModalContentEl.innerHTML = `
              <div>
                <strong>${icao} - ${airportNames[baseIcaoForData] || baseIcaoForData}</strong><br />
                <div>Sunrise (UTC): ${data.sunrise}</div>
                <div>Sunset (UTC): ${data.sunset}</div>
              </div>`;
            document.getElementById('wind-modal').style.display = 'block';
            document.getElementById('info-modal').style.display = 'none';
            loadingDiv.style.display = 'none';
          });
        });
      });
    }

    function showTab(tabsId, type) {
      const tabsContainer = document.getElementById(tabsId);
      if (!tabsContainer) return;
      tabsContainer.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
      tabsContainer.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
      const activeTab = tabsContainer.querySelector(`.tab[data-tab-id="${tabsId}-${type}"]`);
      const activeContent = tabsContainer.querySelector(`#${tabsId}-${type}.tab-content`);
      if (activeTab) activeTab.classList.add('active');
      if (activeContent) activeContent.classList.add('active');
    }
    
    function closeAllModals() {
        document.getElementById('wind-modal').style.display = 'none';
        document.getElementById('info-modal').style.display = 'none';
        document.getElementById('sector-modal').style.display = 'none';
        document.getElementById('modal-wind-content').innerHTML = '';
        document.getElementById('modal-info-content').innerHTML = '';
    }

    document.querySelectorAll('.modal-close').forEach(btn => btn.addEventListener('click', closeAllModals));
    window.addEventListener('click', (event) => {
        if (event.target.classList.contains('modal')) closeAllModals();
    });

    async function getWeather() {
      try {
        clearError();
        const airportCodeInput = document.getElementById("airport-code");
        const input = airportCodeInput.value.trim().toUpperCase();
        if (!input) { showError("Lütfen en az bir havalimanı kodu giriniz."); return; }

        let codes = input.split(",").map(c => c.trim()).filter(c => c);
        if (codes.length === 1 && codes[0] === "LT") codes = [...new Set(allTurkishLTairports)];
        else codes = codes.map(code => iataToIcao[code] || code);
        codes = [...new Set(codes)];
        if (codes.length === 0) { showError("Geçerli bir havalimanı kodu girilmedi."); return; }

        const metarContainer = document.getElementById("metar-taf-container");
        const rightContainer = document.getElementById("right-info-container");
        const loadingDiv = document.getElementById("loading");
        metarContainer.innerHTML = '<div class="progress-bar"><div style="width: 0%"></div></div>';
        loadingDiv.style.display = "flex";

        const allResults = [];
        let failedFetchAttempts = []; 

        let codesToTryCheckWX = [...codes];
        if (codesToTryCheckWX.length > 0) {
            const codeChunks = chunkArray(codesToTryCheckWX, 10);
            for (let i = 0; i < codeChunks.length; i++) {
                const chunk = codeChunks[i];
                loadingDiv.textContent = `CheckWX ile ${codesToTryCheckWX.length} meydan deneniyor... (${allResults.length + Math.min(i*10 + chunk.length, codesToTryCheckWX.length)}/${codes.length})`;
                document.querySelector('.progress-bar div').style.width = `${Math.min(100, ((allResults.length + i*10 + chunk.length) / codes.length) * 50)}%`; // Max 50% for CheckWX
                const promises = chunk.map(code => fetchWeatherForAirport(code, 2, true).catch(e => ({ icao: code, error: e, source: 'CheckWX' })));
                const responses = await Promise.all(promises);
                responses.forEach(res => { if (res && !res.error) allResults.push(res); else failedFetchAttempts.push(res); });
                if (i < codeChunks.length - 1) await new Promise(resolve => setTimeout(resolve, 300));
            }
        }
        
        let codesToTryAVWX = failedFetchAttempts.filter(f => f.source === 'CheckWX').map(f => f.icao);
        failedFetchAttempts = failedFetchAttempts.filter(f => f.source !== 'CheckWX'); // Keep non-CheckWX errors

        if (codesToTryAVWX.length > 0) {
            const codeChunks = chunkArray(codesToTryAVWX, 10);
            for (let i = 0; i < codeChunks.length; i++) {
                const chunk = codeChunks[i];
                loadingDiv.textContent = `AVWX ile ${codesToTryAVWX.length} meydan deneniyor... (${allResults.length + Math.min(i*10+chunk.length, codesToTryAVWX.length)}/${codes.length})`;
                document.querySelector('.progress-bar div').style.width = `${Math.min(100, 50 + ((allResults.length - codesToTryCheckWX.length + i*10 + chunk.length) / codes.length) * 50)}%`; // Max 50% for AVWX
                const promises = chunk.map(code => fetchWeatherForAirport(code, 2, false).catch(e => ({ icao: code, error: e, source: 'AVWX' })));
                const responses = await Promise.all(promises);
                responses.forEach(res => { if (res && !res.error) allResults.push(res); else failedFetchAttempts.push(res);});
                if (i < codeChunks.length - 1) await new Promise(resolve => setTimeout(resolve, 300));
            }
        }
        
        document.querySelector('.progress-bar div').style.width = '100%';


        if (allResults.length === 0) {
          showError("Hiçbir havalimanı için veri alınamadı. Kodları kontrol edin veya daha sonra tekrar deneyin.");
          loadingDiv.style.display = "none"; metarContainer.innerHTML = ''; rightContainer.innerHTML = ''; return;
        }
        
        const finalFailedCodes = failedFetchAttempts.filter(f => f.source === 'AVWX').map(f => f.icao); // Codes that failed both
        if (finalFailedCodes.length > 0) {
          showError(`Veri alınamayan havalimanları (${finalFailedCodes.length}/${codes.length}): ${finalFailedCodes.join(", ")}`);
        } else {
          showError(`Tüm havalimanları başarıyla alındı (${allResults.length}/${codes.length}).`);
        }
        
        const uniqueResults = []; const seenRenderIcaos = new Set();
        allResults.forEach(res => { if (!seenRenderIcaos.has(res.icao)) { uniqueResults.push(res); seenRenderIcaos.add(res.icao);}});

        renderVisibleResults(uniqueResults, metarContainer, rightContainer);
        loadingDiv.style.display = "none";
        airportCodeInput.value = codes.join(',');
      } catch (e) {
        console.error("[DEBUG] Genel Hata getWeather:", e);
        showError("Beklenmeyen bir hata oluştu: " + e.message);
        document.getElementById("loading").style.display = "none";
      }
    }
    
    function populateSectorModal() {
        const tableBody = document.getElementById('sector-table');
        tableBody.innerHTML = ''; 
        const sectorNames = Object.keys(sectorData);
        const numCols = 5; let currentRow;
        sectorNames.forEach((sectorName, index) => {
            if (index % numCols === 0) currentRow = tableBody.insertRow();
            const cell = currentRow.insertCell();
            cell.innerHTML = `<label><input type="checkbox" name="sector" value="${sectorName}"> ${sectorName}</label>`;
        });
    }

    function openSectorModal() {
        populateSectorModal();
        document.getElementById('sector-modal').style.display = 'block';
    }

    function querySectors() {
        const selectedSectors = Array.from(document.querySelectorAll('#sector-table input[type="checkbox"]:checked')).map(cb => cb.value);
        if (selectedSectors.length === 0) { showError("Lütfen en az bir sektör seçin."); return; }
        let icaoCodesFromSectors = selectedSectors.flatMap(sectorName => sectorData[sectorName] || []);
        const airportInput = document.getElementById('airport-code');
        const existingCodes = airportInput.value.split(',').map(c => c.trim()).filter(c => c.length > 0);
        const combinedCodes = [...new Set([...existingCodes, ...icaoCodesFromSectors])];
        airportInput.value = combinedCodes.join(',');
        closeAllModals();
        getWeather();
    }
  </script>
</body>
</html>